# 常用的c++构造对象
  1. 调用::operator new 配置内存
  2. 调用Foo::Foo()构造对象内容
  3. 调用Foo::~Foo()将对象析构
  4. 调用::operator delete 释放内存
```cpp
class Foo{...};
Foo* pf = new Foo();
delete pf;
```
# STL空间配置器构造对象
  1. 通过alloc::allocate()配置内存
  2. 通过::construct()构造对象内容
  3. 通过::destory()析构对象
  4. 通过alloc::deallocate()释放内存
  
  
# ::construct()
  1. 定义
```cpp
template<class T1, class T2>
inline void construct(T1* p,const T2& value){
  //调用placement new 需要包含#inlude<new.h>文件。即在分配好的内存上构造对象。
  new (p) T1(value)
}
  ```
  2. new、operator new、placement new
     1. new操作符对堆中的内存进行申请。是不能被重载的
     2. operator new 就像operator+一样，是可以重载的，但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载
     3. placement new是operator new的一个重载版本。使用new已经分配的内存中创建一个对象，是不行的。即placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。 
     ```cpp
     //placement new原型
     void *operator new( size_t, void *p ) throw()  { return p; }
     ```
# ::destory()
  1. 定义
```cpp
template<class T>
inline void destory(T* pointer){
  pointer->~T();
}
  ```
  
  
# free() 如何释放malloc()申请的空间？  
  malloc()申请的空间实际就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。
  在C语言中，经常用结构来记录信息！下面看看这个结构体的原型：
  ```cpp
  struct mem_control_block { 
    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记
    int size;            //这是实际空间的大小 
    };
  ``` 
  free()就是根据这个结构体的信息来释放malloc()申请的空间

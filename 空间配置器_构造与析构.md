# 常用的c++构造对象
  1. 调用::operator new 配置内存
  2. 调用Foo::Foo()构造对象内容
  3. 调用Foo::~Foo()将对象析构
  4. 调用::operator delete 释放内存
```cpp
class Foo{...};
Foo* pf = new Foo();
delete pf;
```
# STL空间配置器构造对象
  1. 通过alloc::allocate()配置内存
  2. 通过::construct()构造对象内容
  3. 通过::destory()析构对象
  4. 通过alloc::deallocate()释放内存
  
  
# ::construct()
  1. 定义
```cpp
template<class T1, class T2>
inline void construct(T1* p,const T2& value){
  //调用placement new 需要包含#inlude<new.h>文件。即在分配好的内存上构造对象。
  new (p) T1(value)
}
  ```
  2. new、operator new、placement new
     1. new操作符对堆中的内存进行申请。是不能被重载的
     2. operator new 就像operator+一样，是可以重载的，但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载
     3. placement new是operator new的一个重载版本。使用new已经分配的内存中创建一个对象，是不行的。即placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。 
     ```cpp
     //placement new原型
     void *operator new( size_t, void *p ) throw()  { return p; }
     ```
# ::destory()
  1. 定义
```cpp
template<class T>
inline void destory(T* pointer){
  pointer->~T();
}
  ```
  
  
# free() 如何释放malloc()申请的空间？  
  malloc()申请的空间实际就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。
  在C语言中，经常用结构来记录信息！下面看看这个结构体的原型：
  ```cpp
  struct mem_control_block { 
    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记
    int size;            //这是实际空间的大小 
    };
  ``` 
  free()就是根据这个结构体的信息来释放malloc()申请的空间
  
  
# 为什么需要空间配置器?
  1. 小块内存带来的内存碎片问题。
  单从分配的角度来看。由于频繁分配、释放小块内存容易在堆中造成外碎片(极端情况下就是堆中空闲的内存总量满足一个请求，但是这些空闲的块都不连续，导致任何一个单独的空闲的块都无法满足这个请求)。

  2. 小块内存频繁申请释放带来的性能问题。
  开辟空间的时候，分配器会去找一块空闲块给用户，找空闲块也是需要时间的，尤其是在外碎片比较多的情况下。如果分配器其找不到，就要考虑处理假碎片现象(释放的   小块空间没有合并)，这时候就要将这些已经释放的的空闲块进行合并，这也是需要时间的。
  malloc在开辟空间的时候，这些空间会带有一些附加的信息，这样的话也就造成了空间的利用率有所降低，尤其是在频繁申请小块内存的时候。
  
# 如何解决内存碎片和内存频繁开辟释放的性能问题？
  通过使用内存池,内存池最基本的思想就是一次向heap申请一块很大的内存(内存池)，如果申请小块内存的话就直接到内存池中去要。
  
# 使用空间配置器的带来的问题：
  1. 在空间配置器中所有的函数和变量都是静态的，所以他们在程序结束的时候才会被释放发。二级空间配置器中没有将申请的内存还给操作系统，只是将他们挂在自由链   表上。所以说只有当你的程序结束了之后才会将开辟的内存还给操作系统。
  2. 由于它没有将内存还给操作系统，所以就会出现二种极端的情况。
     1. 假如我不断的开辟小块内存，最后将整个heap上的内存都挂在了自由链表上，但是都没有用这些空间，再想要开辟一个大块内存的话会开辟失败。
     2. 再比如我不断的开辟char,最后将整个heap内存全挂在了自由链表的第一个结点的后面，这时候我再想开辟一个16个字节的内存，也会失败
  3. 二级空间配置器会造成内碎片问题，极端的情况下一直申请char，则就会浪费7/8的空间。但是整体来说，空间配置器的性能还是蛮高的。



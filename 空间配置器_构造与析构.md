# 常用的c++构造对象
  1. 调用::operator new 配置内存
  2. 调用Foo::Foo()构造对象内容
  3. 调用Foo::~Foo()将对象析构
  4. 调用::operator delete 释放内存
```cpp
class Foo{...};
Foo* pf = new Foo();
delete pf;
```
# STL空间配置器构造对象
  1. 通过alloc::allocate()配置内存
  2. 通过::construct()构造对象内容
  3. 通过::destory()析构对象
  4. 通过alloc::deallocate()释放内存
  
  
# ::construct()
  1. 定义
```cpp
template<class T1, class T2>
inline void construct(T1* p,const T2& value){
  //调用placement new 需要包含#inlude<new.h>文件。即在分配好的内存上构造对象。
  new (p) T1(value)
}
  ```
  2. new、operator new、placement new
     1. new操作符对堆中的内存进行申请。是不能被重载的
     2. operator new 就像operator+一样，是可以重载的，但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载
     3. placement new是operator new的一个重载版本。使用new已经分配的内存中创建一个对象，是不行的。即placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。 
     ```cpp
     //placement new原型
     void *operator new( size_t, void *p ) throw()  { return p; }
     ```
# ::destory()
  1. 定义
```cpp
template<class T>
inline void destory(T* pointer){
  pointer->~T();
}
  ```
  
  
# free() 如何释放malloc()申请的空间？  
  malloc()申请的空间实际就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。
  在C语言中，经常用结构来记录信息！下面看看这个结构体的原型：
  ```cpp
  struct mem_control_block { 
    int is_available;    //一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记
    int size;            //这是实际空间的大小 
    };
  ``` 
  free()就是根据这个结构体的信息来释放malloc()申请的空间
  
  
# 为什么需要空间配置器?
  1. 小块内存带来的内存碎片问题。
  单从分配的角度来看。由于频繁分配、释放小块内存容易在堆中造成外碎片(极端情况下就是堆中空闲的内存总量满足一个请求，但是这些空闲的块都不连续，导致任何一个单独的空闲的块都无法满足这个请求)。

  2. 小块内存频繁申请释放带来的性能问题。
  开辟空间的时候，分配器会去找一块空闲块给用户，找空闲块也是需要时间的，尤其是在外碎片比较多的情况下。如果分配器其找不到，就要考虑处理假碎片现象(释放的   小块空间没有合并)，这时候就要将这些已经释放的的空闲块进行合并，这也是需要时间的。
  malloc在开辟空间的时候，这些空间会带有一些附加的信息，这样的话也就造成了空间的利用率有所降低，尤其是在频繁申请小块内存的时候。
  
# 如何解决内存碎片和内存频繁开辟释放的性能问题？
  通过使用内存池,内存池最基本的思想就是一次向heap申请一块很大的内存(内存池)，如果申请小块内存的话就直接到内存池中去要。



  
* list和vector的区别
  - vector使用连续内存存储的，他支持[]运算符。Vector对于随机访问的速度很快，但是对于插入尤其是在头部插入元素速度很慢，在尾部插入速度很快
  - list是以链表形式实现的，不支持[]。List对于随机访问速度慢得多，因为可能要遍历整个链表才能做到，但是对于插入就快的多了，不需要拷贝和移动数据，只需要     改变指针的指向就可以了
 
* inline 内联函数特征
  - 相当于把内联函数里面的内容写在调用内联函数处；
  - 相当于不用执行进入函数的步骤，直接执行函数体；
  - 相当于宏，却比宏多了类型检查，真正具有函数特性；
  - 不能包含循环、递归、switch 等复杂操作；
  - 类中除了虚函数的其他函数都会自动隐式地当成内联函数。
  




* sizeof()
  - sizeof 对数组，得到整个数组所占空间大小。
  - sizeof 对指针，得到指针本身所占空间大小。

* extern "C"
  - 被 extern 限定的函数或变量是 extern 类型的
  - 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的
  - extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题

* C++ 中struct 和class 区别
  - struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

* explicit（显式）构造函数
  - explicit 修饰的构造函数可用来防止隐式转换 
    ```cpp
    class Test1
    {
    public:
        Test1(int n)            // 普通构造函数
        {
            num=n;
        }
    private:
        int num;
    };

    class Test2
    {
    public:
        explicit Test2(int n)   // explicit（显式）构造函数
        {
            num=n;
        }
    private:
        int num;
    };

    int main()
    {
        Test1 t1=12;            // 隐式调用其构造函数，成功
        Test2 t2=12;            // 编译错误，不能隐式调用其构造函数
        Test2 t2(12);           // 显式调用成功
        return 0;
    }
    ```




        


* 什么是平衡二叉树？
  - 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。

* 堆栈溢出一般是由什么原因导致的？
  - 没有回收垃圾资源。


      
      

 

        
* C和C++的区别？
  - C++在C的基础上增添类
  - C是一个结构化语言，它的重点在于算法和数据结构。
  - C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象     模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。





* 堆和栈的区别？堆和栈的生命周期？
  - 堆栈空间分配区别：
    1. 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
    2. 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
  - 堆栈缓存方式区别：
    1. 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
    2. 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
  - 堆栈数据结构区别：
    1. 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
    2. 栈（数据结构）：一种先进后出的数据结构。
    
* delete 与 delete[]区别
  - delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。
  

  
* main 函数执行以前，还会执行什么代码？
  - 全局对象的构造函数会在main 函数之前执行。
  
* 描述内存分配方式以及它们的区别?
  - 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
  - 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
  - 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期     由程序员决定，使用非常灵活，但问题也最多。

* 分别写出 bool,int,float,指针类型的变量 a 与“零”的比较语句。
  ```CPP
  bool : if(!a) or if(a)
  int : if(a==0) 或 if(!a)
  float : const EXPRESSION EXP=0.000001 if (a-EXP)
  pointer : if (a != NULL) or if(a == NULL)
  ```


  

  
* C++ 编译器自动为类产生的四个缺省函数是什么?
  - 默认构造函数，拷贝构造函数，析构函数，赋值函数。
  

  

    
* C++中有了malloc / free,为什么还需要 new / delete
  - malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存
  - 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数
    由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free
  - 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数

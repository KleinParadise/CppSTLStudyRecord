* const作用
  - 修饰变量，说明该变量不可以被改变；
  - 修饰指针，分为指向常量的指针和指针常量；
  - 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
  - 修饰成员函数，说明该成员函数内不能修改成员变量。


* static作用
  - 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统     用默认值初始化它。
  - 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
  - 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
  - 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

* this 指针
  - this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
  - 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。
  - 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
  - this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const       ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
  - this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
  - 在以下场景中，经常需要显式引用 this 指针：
    1. 为实现对象的链式引用；
    2. 为避免对同一对象进行赋值操作；
    3. 在实现一些数据结构时，如 list。
    
* inline 内联函数特征
  - 相当于把内联函数里面的内容写在调用内联函数处；
  - 相当于不用执行进入函数的步骤，直接执行函数体；
  - 相当于宏，却比宏多了类型检查，真正具有函数特性；
  - 不能包含循环、递归、switch 等复杂操作；
  - 类中除了虚函数的其他函数都会自动隐式地当成内联函数。
  
* 什么是宏，它解决什么问题？
  - 宏的本质是文本替换，考虑下面的需求，程序中多次使用圆周率Pi，在每个地方都使用3.1415，显然很愚蠢。有没有好的办法呢？使用宏，如下：
　　#define Pi 3.1415
　　这样，编译器在程序中遇到Pi，就使用3.1415来进行文本替换。

* 虚函数（virtual）可以是内联函数（inline）吗？
  - 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
  - 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
  - inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类如 Base::who()这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

* sizeof()
  - sizeof 对数组，得到整个数组所占空间大小。
  - sizeof 对指针，得到指针本身所占空间大小。

* extern "C"
  - 被 extern 限定的函数或变量是 extern 类型的
  - 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的
  - extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题

* C++ 中struct 和class 区别
  - struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

* explicit（显式）构造函数
  - explicit 修饰的构造函数可用来防止隐式转换 
    ```cpp
    class Test1
    {
    public:
        Test1(int n)            // 普通构造函数
        {
            num=n;
        }
    private:
        int num;
    };

    class Test2
    {
    public:
        explicit Test2(int n)   // explicit（显式）构造函数
        {
            num=n;
        }
    private:
        int num;
    };

    int main()
    {
        Test1 t1=12;            // 隐式调用其构造函数，成功
        Test2 t2=12;            // 编译错误，不能隐式调用其构造函数
        Test2 t2(12);           // 显式调用成功
        return 0;
    }
    ```

* 重载（overload）
  - 指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。
    1.  相同的范围（在同一个作用域中） ；
    2.  函数名字相同；
    3.  参数不同；
    4.  virtual 关键字可有可无。
    5.  返回值可以不同；
    
* 重写（也称为覆盖 override）
  - 是指派生类重新定义基类的虚函数，特征是：
    1. 不在同一个作用域（分别位于派生类与基类） ；
    2. 函数名字相同；
    3. 参数相同；
    4. 基类函数必须有 virtual 关键字，不能有 static 。
    5. 返回值相同（或是协变），否则报错；<—-协变这个概念我也是第一次才知道…
    6. 重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的
    
 * 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？
    - 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
    - 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：         function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于       这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
    - 重写：是指子类重新定义父类虚函数的方法。
    - 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无       法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

* 引用与指针有什么区别？
  - 引用必须被初始化，指针不必。
  - 引用初始化以后不能被改变，指针可以改变所指的对象。
  - 不存在指向空值的引用，但是存在指向空值的指针。
        
* 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
  - 全局变量储存在静态数据库，局部变量在堆栈。

* 什么是平衡二叉树？
  - 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。

* 堆栈溢出一般是由什么原因导致的？
  - 没有回收垃圾资源。

* 什么函数不能声明为虚函数？
  - constructor函数不能声明为虚函数
      
      
* int const * const p;有一个简便的办法记忆。从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”。
```cpp
    const int p; //常量整数
    const int* p; //p is a point to int const.p是一个指向整型常量的指针
    int const* p; //p is a point to const int 同上
    int * const p;//p is a const point to int.p是一个常量指针，指向整型。
    const int * const p;//p is a const point to int const.
    int const * const p;//p is a const point to const int 同上p都是常量指针，指向整型常量
 ```
 
* 什么时候要用虚析构函数
  - 通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚的。否则其删除效果将无法实现。一般情况下，这样的删除只能够删除基类对象，而不能删除子类对       象，形成了删除一半形象，从而千万内存泄漏。
  - 在公有继承中，基类对派生类及其对象的操作，只能影响到那些从基类继承下来的成员。如果想要用基类对非继承成员进行操作，则要把基类的这个操作（函数）定义为     虚函数。那么，析构函数自然也应该如此：如果它想析构子类中的重新定义或新的成员及对象，当然也应该声明为虚的。
  - 如果不需要基类对派生类及对象进行操作，则不能定义虚函数（包括虚析构函数），因为这样会增加内存开销。
  
* C++中有了malloc / free,为什么还需要 new / delete?  
  - malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
  - 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
     由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
  - 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
      
* C和C++的区别？
  - C++在C的基础上增添类
  - C是一个结构化语言，它的重点在于算法和数据结构。
  - C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象     模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

* 子类析构时要调用父类的析构函数吗？
  - 析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然     后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

* 多态，虚函数，纯虚函数
  - 多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：
    1. 在程序运行时的多态性通过继承和虚函数来体现；
    2. 在程序编译时多态性体现在函数和运算符的重载上；
  - 虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
  - 纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。
   从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。
   抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。


* 堆和栈的区别？堆和栈的生命周期？
  - 堆栈空间分配区别：
    1. 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
    2. 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
  - 堆栈缓存方式区别：
    1. 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
    2. 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
  - 堆栈数据结构区别：
    1. 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
    2. 栈（数据结构）：一种先进后出的数据结构。
